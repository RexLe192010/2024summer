今天需要测试一下gpt4的auto-formalization和设计/修正lib的能力，设计了一些example，需要测试多种组合带来的不同结果

System message: You are an AI assistant that translates natural language to Lean4. Output Lean4 code only. All calculations, derivations, and validations should be performed in Lean4. Do not use begin/end in the output.

After putting all together: Given this library, solve for y: 3y + 2 = y - 3 + 4 y.

If wrong: Wrong result. Either correct the code I gave you or correct your solution.

1. To prove that two sets are equal, it suffices to show that every element of one is an element of the other. This principle is known as “extensionality,” and, the ext tactic is equipped to handle it.

example : s ∩ t = t ∩ s := by
  ext x
  simp only [mem_inter_iff]
  constructor
  · rintro ⟨xs, xt⟩; exact ⟨xt, xs⟩
  . rintro ⟨xt, xs⟩; exact ⟨xs, xt⟩

2. Using the theorem le_antisymm, we can show that two real numbers are equal if each is less than or equal to the other. We can show that min is commutative.

example : min a b = min b a := by
  apply le_antisymm
  · show min a b ≤ min b a
    apply le_min
    · apply min_le_right
    apply min_le_left
  · show min b a ≤ min a b
    apply le_min
    · apply min_le_right
    apply min_le_left

3. Distances are always nonnegative in a metric space.

section

variable {X : Type*} [MetricSpace X]
variable (x y z : X)

example (x y : X) : 0 ≤ dist x y :=by
  have : 0 ≤ dist x y + dist y x := by
    rw [← dist_self x]
    apply dist_triangle
  linarith [dist_comm x y]

end

4. A function f has an upper bound if there exists a real number a such that for all inputs x, f(x) is less than or equal to a;
a function has a lower bound if there exists a real number a such that for all inputs x, f(x) is greater than or equal to a.

def FnUb (f : ℝ → ℝ) (a : ℝ) : Prop :=
  ∀ x, f x ≤ a

def FnLb (f : ℝ → ℝ) (a : ℝ) : Prop :=
  ∀ x, a ≤ f x








接下去是试验结果，由于每次输出结果稍微有差距，因此具体的trace得看math in lean的repo


（1）1234同时使用：
theorem solve_example_3y_plus_2_eq_y_minus_3_plus_4y : ∀ y, 3 * y + 2 = y - 3 + 4 * y ↔ y = -5 :=
  ⟨
    fun hy =>
      have : 3 * y + 2 = 5 * y - 3 := by
        linarith
      have : 2 * y = -5 := by
        linarith
      show y = -5 / 2 from eq_div_of_mul_eq two_ne_zero this,
    fun hy =>
      by rw [hy]
      simp
  ⟩
提醒一遍错误之后，
theorem solve_example_3y_plus_2_eq_y_minus_3_plus_4y (y : ℝ) : 3 * y + 2 = y - 3 + 4 * y ↔ y = -5 :=
  ⟨
    fun h =>
      have h1 : 3 * y + 2 = 5 * y - 3 := by
        simp at h
        exact h
      have h2 : 2 * y = -5 := by
        linarith
      show y = -5 / 2 from eq_of_mul_eq_mul_left two_ne_zero h2,
    fun h =>
      by rw [h]
      simp
  ⟩
把对于任意y改成了y属于实数集，算是有所改进，但是结果仍然不对



（2）134：
section
variable (y : ℝ)

example : 3 * y + 2 = y - 3 + 4 * y → y = 1 :=
  assume h : 3 * y + 2 = y - 3 + 4 * y,
  have h1 : 3 * y + 2 = 5 * y - 3, by rw [← add_assoc, ← add_mul, h],
  have h2 : 2 * y = -5, from calc
    2 * y = (5 * y - 3) - (3 * y) - 2 : by rw [← sub_sub, ← sub_eq_iff_eq_add'.mpr h1]
    ... = 5 * y - 3 * y - 3 - 2 : by rw [sub_sub]
    ... = 2 * y - 5 : by norm_num,
  calc
    y = (-5) / 2 : by rw [← h2, ← div_eq_mul_inv, mul_comm, mul_assoc, inv_mul_cancel (by norm_num : (2 : ℝ) ≠ 0), mul_one]
    ... = 1 : by norm_num

end

-- 提醒wrong result之后

section
variable (y : ℝ)

example : 3 * y + 2 = y - 3 + 4 * y → y = -5 :=
  assume h : 3 * y + 2 = y - 3 + 4 * y,
  have h1 : 3 * y + 2 = 5 * y - 3, from calc
    3 * y + 2 = y - 3 + 4 * y : by rw h
    ... = y + 4 * y - 3 : by rw add_sub_assoc
    ... = 5 * y - 3 : by rw add_mul,
  have h2 : 2 = 2 * y - 3, from calc
    2 = 3 * y + 2 - 3 * y : by rw add_sub_cancel
    ... = (5 * y - 3) - 3 * y : by rw h1
    ... = 5 * y - 3 * y - 3 : by rw sub_sub
    ... = 2 * y - 3 : by rw two_mul,
  have h3 : 2 + 3 = 2 * y, from calc
    2 + 3 = 2 * y : by rw ← h2
    ... = 2 * y : by norm_num,
  calc
    y = 5 / 2 : by rw ← h3
    ... = -5 : by norm_num

end
这个效果明显比前面一个要好，所有内容全都包括在了section-end当中；个人认为3这个例子是非加不可了，section-end真的十分好用
提醒过后好像离正确答案近了一点，但是rw后面又不加【】了
最后的答案虽然还是不对（逆天gpt4，5/2=-5）但是修改后的过程更简洁





（3）234：
section
variable (y : ℝ)

def solve_linear_equation_3y_plus_2_eq_y_minus_3_plus_4y : ℝ :=
  -5 / 2

-- Check the solution
example : 3 * solve_linear_equation_3y_plus_2_eq_y_minus_3_plus_4y + 2 = solve_linear_equation_3y_plus_2_eq_y_minus_3_plus_4y - 3 + 4 * solve_linear_equation_3y_plus_2_eq_y_minus_3_plus_4y := by
  have : 3 * (-5 / 2) + 2 = (-5 / 2) - 3 + 4 * (-5 / 2) := by
    calc
      3 * (-5 / 2) + 2 = -15 / 2 + 2 : by norm_num
                     _ = -15 / 2 + 4 / 2 : by rw [←two_mul, ←div_mul_cancel _ two_ne_zero]
                     _ = (-15 + 4) / 2 : by rw [add_div]
                     _ = -11 / 2 : by norm_num
                     _ = -5 / 2 - 3 + 4 * (-5 / 2) : by simp only [eq_self_iff_true, neg_add_rev, neg_mul_eq_neg_mul_symm, neg_neg]
  exact this


-- 提醒错误结果之后，

def solve_linear_equation_3y_plus_2_eq_y_minus_3_plus_4y : ℝ :=
  -1

-- Check the solution
example : 3 * solve_linear_equation_3y_plus_2_eq_y_minus_3_plus_4y + 2 = solve_linear_equation_3y_plus_2_eq_y_minus_3_plus_4y - 3 + 4 * solve_linear_equation_3y_plus_2_eq_y_minus_3_plus_4y := by
  have : 3 * (-1) + 2 = (-1) - 3 + 4 * (-1) := by
    calc
      3 * (-1) + 2 = -3 + 2 : by norm_num
                  _ = -1    : by norm_num
                  _ = -1 - 3 : by norm_num
                  _ = -4    : by norm_num
                  _ = -1 - 3 + 4 * (-1) : by norm_num
  exact this
这边两次得到的解分别是-5 / 2和-1，并且通过证明的方式来说明解是正确的（然而是错的）
又是一波逆天暴论，完全不知道是怎么来到这一步的



（4）34
variables (hy : y ≠ 0)

-- Solve the equation 3y + 2 = y - 3 + 4y
def solve_linear_eq_new : ℝ :=
  (-2 - (-3)) / (4 - 3)

-- Check the solution
theorem check_linear_eq_new : 3 * solve_linear_eq_new + 2 = solve_linear_eq_new - 3 + 4 * solve_linear_eq_new :=
begin
  unfold solve_linear_eq_new,
  field_simp,
  norm_num,
end


-- 提醒一遍之后

variables {y : ℝ}

-- Solve the equation 3y + 2 = y - 3 + 4y
def solve_linear_eq_new : ℝ :=
  (-2 + 3) / (3 + 4 - 1)

theorem check_linear_eq_new : 3 * solve_linear_eq_new + 2 = solve_linear_eq_new - 3 + 4 * solve_linear_eq_new :=
begin
  unfold solve_linear_eq_new,
  linarith,
end

可以发现这边又开始莫名其妙地使用起了begin-end结构（我甚至在system message里面提醒过）
因此一定数量的examples必不可少


（5）3
section

variable {R : Type*} [Field R]

-- Solve 3y + 2 = y - 3 + 4y for y
def solve_example_new (hy : (2 : R) ≠ 0) : R :=
  let y := solve_linear_eq2 6 (-3) 2 hy in
  have check : 3 * y + 2 = y - 3 + 4 * y, from by
    change 3 * (2 / 6) + 2 = (2 / 6) - 3 + 4 * (2 / 6)
    field_simp [hy]
    ring
  y

end


-- 提醒错误之后

section

variable {R : Type*} [Field R]

-- Solve 3y + 2 = y - 3 + 4y for y
def solve_example_new : R :=
  let y := solve_linear_eq2 2 2 (-3) (by norm_num : (2 : R) ≠ 0) in
  y

end
第一个至少有解，算出来2/6=1/3，提醒之后没有修正，反而连答案都不给了（可能是因为直接调用了前面的function，也还不错）
唯一好的一点，是过程中没有用到begin-end，同时也用section-end将一个个block区分开来


（6）123
variable {y : ℝ}

example : 3*y + 2 = y - 3 + 4*y ↔ y = -5 := by
  constructor
  · intro h
    have four_y_eq : 3*y + 2 = 5*y - 3 := by
      linarith
    have y_eq : 2*y = -5 := by
      linarith
    exact eq_div_iff (by norm_num).mp y_eq
  · intro h
    rw h
    norm_num


-- 提醒错误之后

example : 3 * y + 2 = y - 3 + 4 * y ↔ y = -5 := by
  linarith
两次得出的结果都是-5，虽然结构也很清晰（尝试证明方程等价于y=-5）但从结果来看没有意义


（7）23
example : 3 * y + 2 = y - 3 + 4 * y ↔ y = -5 := by
  constructor
  · intro h
    linarith
  · intro h
    rw h
    norm_num


-- 提醒错误之后

example : 3 * y + 2 = y - 3 + 4 * y ↔ y = 1 := by
  constructor
  · intro h
    linarith
  · intro h
    rw h
    norm_num
这个结构还算清晰，得出的解分别是-5和1，并且尝试证明解是对的


